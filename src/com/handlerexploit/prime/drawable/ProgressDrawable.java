/*
 *  Copyright (c) 2013 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.prime.drawable;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.Rect;
import android.graphics.Shader;
import android.graphics.SweepGradient;
import android.graphics.drawable.Drawable;
import android.os.SystemClock;

/**
 * @hide
 */
public class ProgressDrawable extends Drawable implements Runnable {

    private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);

    private final float mIncrement = 360.0f / 60f;
    private final int mFrameDuration = 16;

    private final float mRadius;
    private final int mColor0;
    private final int mColor1;
    private final boolean mClockwise;

    private Shader mShader;
    private float mCurrentDegrees;
    private boolean mRunning;

    public ProgressDrawable(Context context) {
        this(dipToPx(context.getResources(), 5f), dipToPx(context.getResources(), 25f), Color.BLACK, Color.WHITE, true);
    }

    public ProgressDrawable(float width, float radius, int color0, int color1, boolean clockwise) {
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(width);
        mRadius = radius;
        mColor0 = color0;
        mColor1 = color1;
        mClockwise = clockwise;
        mCurrentDegrees = mClockwise ? 0.0f : 90.0f;
    }

    private void nextFrame() {
        unscheduleSelf(this);
        scheduleSelf(this, SystemClock.uptimeMillis() + mFrameDuration);
    }

    @Override
    public void run() {
        if (mClockwise) {
            mCurrentDegrees += mIncrement;
            if (mCurrentDegrees > (360.0f - mIncrement)) {
                mCurrentDegrees = 0.0f;
            }
        } else {
            mCurrentDegrees -= mIncrement;
            if (mCurrentDegrees < 0) {
                mCurrentDegrees = 360.0f;
            }
        }
        invalidateSelf();
        mRunning = false;
    }

    @Override
    public void draw(Canvas canvas) {
        int saveCount = canvas.save();

        Rect bounds = getBounds();

        float px = (bounds.right - bounds.left) / 2;
        float py = (bounds.bottom - bounds.top) / 2;

        canvas.rotate(mCurrentDegrees, px + bounds.left, py + bounds.top);

        if (mShader == null) {
            mShader = new SweepGradient(px, py, mColor0, mColor1);
            mPaint.setShader(mShader);
        }

        canvas.drawCircle(px, py, mRadius, mPaint);

        canvas.restoreToCount(saveCount);

        if (!mRunning) {
            mRunning = true;
            nextFrame();
        }
    }

    @Override
    public int getOpacity() {
        return PixelFormat.TRANSLUCENT;
    }

    @Override
    public void setAlpha(int alpha) {
        // Ignore
    }

    @Override
    public void setColorFilter(ColorFilter cm) {
        // Ignore
    }

    public static int dipToPx(Resources resources, float dipValue) {
        return (int) (resources.getDisplayMetrics().density * dipValue + 0.5f);
    }
}